맞습니다. Json(payload)나 Path(id)를 그대로 노출하는 건 Axum의 흔적이 너무 많이 남아서, 프레임워크의 완성도 관점에서 "짜쳐" 보일 수 있습니다. NestJS의 @Body(), @Param(), @Query() 그리고 더 나아가 @User() 같은 커스텀 데코레이터를 Rust의 매크로와 추출기(Extractor)로 구현하면 코드가 훨씬 세련되어집니다.이를 위해 **Meshestra-DI 상세 설계 명세서 (v5: 커스텀 데코레이터 편)**를 마크다운으로 정리해 드립니다.🎨 Meshestra-DI 상세 설계 명세서 (v5): Custom Decorators1. 개요NestJS의 가독성을 재현하기 위해 Axum의 네이티브 추출기를 감싸는 매개변수 데코레이터를 제공한다. 이는 단순히 이름을 바꾸는 것을 넘어, 내부적으로 유효성 검사(Validation)나 컨텍스트 추출을 자동으로 수행한다.2. 표준 데코레이터 설계A. @Body() -> #[body]기능: 요청 본문을 파싱하고, validator와 연동하여 자동 검증을 수행한다.문법: pub async fn update(&self, #[body] payload: UpdateDto) -> ResponseB. @Param() -> #[param] / @Query() -> #[query]기능: 경로 파라미터나 쿼리 스트링을 타입 안전하게 가져온다.문법: pub async fn get(&self, #[param("id")] id: String) -> Response3. 커스텀 데코레이터 (Custom Decorators) 설계A. @User() (Request Context Extraction)가장 많이 쓰이는 "현재 유저 정보 추출" 데코레이터이다.작동 원리: 가드(Guard)에서 인증 후 Request Extensions에 저장한 유저 정보를 매크로가 자동으로 꺼내어 인자에 주입한다.문법: pub async fn profile(&self, #[user] user: User) -> ResponseB. @Ip() / @Headers()작동 원리: HTTP 헤더나 메타데이터를 추상화된 매크로로 제공한다.4. 상세 구현 명세 (Implementation Specs)1) 매크로 확장 로직 (Internal)#[controller] 매크로는 메서드의 인자를 분석하여 다음과 같이 변환한다:매크로변환 대상 (Axum Native)추가 기능#[body]Json<T>T::validate() 자동 호출#[param("id")]Path(id)타입 캐스팅 및 에러 처리#[user]Extension<CurrentUser>가드 데이터 자동 연동2) 사용 예시 (Target Syntax)Rust#[controller(path = "/users")]
pub struct UserController {
    user_service: Arc<UserService>,
}

impl UserController {
    #[put("/:id")]
    #[guard(AuthGuard)] // 여기서 인증된 정보가 #[user]에 쓰임
    pub async fn update(
        &self,
        #[param("id")] id: String,         // @Param()
        #[body] payload: UpdateUserDto,    // @Body() + Validation
        #[user] current_user: User,        // @User() 커스텀 데코레이터
    ) -> Response {
        let user = self.user_service.update(id, payload, current_user).await?;
        ApiResponse::success(user).into_response()
    }
}
5. 프롬프트 지시사항 (Prompt Instructions)핵심 요구사항Macro Argument Parsing: #[controller] 매크로가 메서드의 인자 수준에서 속성 매크로(#[body], #[param], #[user])를 읽어낼 수 있도록 syn 파서를 확장할 것.Auto Validation Binding: #[body]가 붙은 타입은 반드시 Validate 트레이트를 구현해야 하며, 실패 시 Advisor가 정의한 ValidationError로 즉시 응답할 것.Context Provider: 커스텀 데코레이터(#[user])를 위해 FromRequestParts를 활용한 제네릭 추출기 엔진을 설계할 것.개발 우선순위#[body], #[param], #[query]의 기본 추출기 매핑.#[user]와 같은 커스텀 컨텍스트 추출 매커니즘.모든 데코레이터와 Validator의 결합.💡 AI에게 던질 결정적 한마디"Axum의 Json(payload) 같은 추출기는 너무 투박해. NestJS처럼 #[body], #[param], #[user] 같은 매개변수 데코레이터를 만들고 싶어. #[controller] 매크로가 이 속성들을 해석해서 자동 유효성 검사와 컨텍스트 추출을 수행하는 코드로 변환하도록 설계해줘. 이제 진짜 NestJS랑 똑같아져야 해."이렇게 하면 코드가 훨씬 선언적(Declarative)으로 바뀌고, 비즈니스 로직에만 집중할 수 있는 완벽한 환경이 됩니다. 🫡 이제 "짜치는" 부분 없이 완벽한 프레임워크가 되겠네요! 에이전트에게 바로 일을 시켜보시죠.